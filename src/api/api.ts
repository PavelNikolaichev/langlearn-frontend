/* tslint:disable */
/* eslint-disable */
/**
 * LangLearn API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base'

export interface AuthResultDto {
  success?: boolean
  message?: string | null
  token?: string | null
  expiresAt?: string | null
}
export interface Deck {
  id?: string
  name: string
  description?: string | null
  userId: string
  user?: User
  flashcards?: Array<Flashcard> | null
  createdAt: string
  updatedAt: string
}
export interface DeckDto {
  id?: string
  name?: string | null
  description?: string | null
  createdAt?: string
  updatedAt?: string
  flashcards?: Array<FlashcardDto> | null
}
export interface Flashcard {
  id?: string
  front: string
  back: string
  notes?: string | null
  userId: string
  user?: User
  deckId: string
  createdAt: string
  updatedAt: string
}
export interface FlashcardDto {
  id?: string
  front?: string | null
  back?: string | null
  notes?: string | null
  createdAt?: string
  updatedAt?: string
}
export interface Grammar {
  id?: string
  name: string
  description?: string | null
  userId: string
  user?: User
  grammarSetId: string
  createdAt: string
  updatedAt: string
}
export interface GrammarDto {
  id?: string
  name?: string | null
  description?: string | null
  createdAt?: string
  updatedAt?: string
}
export interface GrammarSet {
  id?: string
  name: string
  description?: string | null
  userId: string
  user?: User
  grammars?: Array<Grammar> | null
  createdAt: string
  updatedAt: string
}
export interface GrammarSetDto {
  id?: string
  name?: string | null
  description?: string | null
  createdAt?: string
  updatedAt?: string
  grammars?: Array<GrammarDto> | null
}
export interface LoginRequestDto {
  email?: string | null
  password?: string | null
}
export interface RefreshTokenRequestDto {
  token?: string | null
}
export interface RegisterRequestDto {
  email?: string | null
  password?: string | null
}
export interface User {
  id?: string
  email?: string | null
  passwordHash?: string | null
}

/**
 * LangLearnBackendApi - axios parameter creator
 */
export const LangLearnBackendApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/auth`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {LoginRequestDto} loginRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authLoginPost: async (
      loginRequestDto: LoginRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginRequestDto' is not null or undefined
      assertParamExists('authLoginPost', 'loginRequestDto', loginRequestDto)
      const localVarPath = `/auth/login`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        loginRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {RefreshTokenRequestDto} refreshTokenRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authRefreshPost: async (
      refreshTokenRequestDto: RefreshTokenRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'refreshTokenRequestDto' is not null or undefined
      assertParamExists('authRefreshPost', 'refreshTokenRequestDto', refreshTokenRequestDto)
      const localVarPath = `/auth/refresh`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        refreshTokenRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {RegisterRequestDto} registerRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authRegisterPost: async (
      registerRequestDto: RegisterRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'registerRequestDto' is not null or undefined
      assertParamExists('authRegisterPost', 'registerRequestDto', registerRequestDto)
      const localVarPath = `/auth/register`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        registerRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} deckId
     * @param {string} flashcardId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decksDeckIdFlashcardsFlashcardIdDelete: async (
      deckId: string,
      flashcardId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'deckId' is not null or undefined
      assertParamExists('decksDeckIdFlashcardsFlashcardIdDelete', 'deckId', deckId)
      // verify required parameter 'flashcardId' is not null or undefined
      assertParamExists('decksDeckIdFlashcardsFlashcardIdDelete', 'flashcardId', flashcardId)
      const localVarPath = `/decks/{deckId}/flashcards/{flashcardId}`
        .replace(`{${'deckId'}}`, encodeURIComponent(String(deckId)))
        .replace(`{${'flashcardId'}}`, encodeURIComponent(String(flashcardId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} deckId
     * @param {string} flashcardId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decksDeckIdFlashcardsFlashcardIdGet: async (
      deckId: string,
      flashcardId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'deckId' is not null or undefined
      assertParamExists('decksDeckIdFlashcardsFlashcardIdGet', 'deckId', deckId)
      // verify required parameter 'flashcardId' is not null or undefined
      assertParamExists('decksDeckIdFlashcardsFlashcardIdGet', 'flashcardId', flashcardId)
      const localVarPath = `/decks/{deckId}/flashcards/{flashcardId}`
        .replace(`{${'deckId'}}`, encodeURIComponent(String(deckId)))
        .replace(`{${'flashcardId'}}`, encodeURIComponent(String(flashcardId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} deckId
     * @param {string} flashcardId
     * @param {Flashcard} flashcard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decksDeckIdFlashcardsFlashcardIdPatch: async (
      deckId: string,
      flashcardId: string,
      flashcard: Flashcard,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'deckId' is not null or undefined
      assertParamExists('decksDeckIdFlashcardsFlashcardIdPatch', 'deckId', deckId)
      // verify required parameter 'flashcardId' is not null or undefined
      assertParamExists('decksDeckIdFlashcardsFlashcardIdPatch', 'flashcardId', flashcardId)
      // verify required parameter 'flashcard' is not null or undefined
      assertParamExists('decksDeckIdFlashcardsFlashcardIdPatch', 'flashcard', flashcard)
      const localVarPath = `/decks/{deckId}/flashcards/{flashcardId}`
        .replace(`{${'deckId'}}`, encodeURIComponent(String(deckId)))
        .replace(`{${'flashcardId'}}`, encodeURIComponent(String(flashcardId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        flashcard,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} deckId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decksDeckIdFlashcardsGet: async (
      deckId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'deckId' is not null or undefined
      assertParamExists('decksDeckIdFlashcardsGet', 'deckId', deckId)
      const localVarPath = `/decks/{deckId}/flashcards`.replace(
        `{${'deckId'}}`,
        encodeURIComponent(String(deckId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} deckId
     * @param {Flashcard} flashcard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decksDeckIdFlashcardsPost: async (
      deckId: string,
      flashcard: Flashcard,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'deckId' is not null or undefined
      assertParamExists('decksDeckIdFlashcardsPost', 'deckId', deckId)
      // verify required parameter 'flashcard' is not null or undefined
      assertParamExists('decksDeckIdFlashcardsPost', 'flashcard', flashcard)
      const localVarPath = `/decks/{deckId}/flashcards`.replace(
        `{${'deckId'}}`,
        encodeURIComponent(String(deckId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        flashcard,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decksGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/decks`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decksIdDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('decksIdDelete', 'id', id)
      const localVarPath = `/decks/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decksIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('decksIdGet', 'id', id)
      const localVarPath = `/decks/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {Deck} deck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decksIdPatch: async (
      id: string,
      deck: Deck,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('decksIdPatch', 'id', id)
      // verify required parameter 'deck' is not null or undefined
      assertParamExists('decksIdPatch', 'deck', deck)
      const localVarPath = `/decks/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        deck,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {Deck} deck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decksPost: async (deck: Deck, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'deck' is not null or undefined
      assertParamExists('decksPost', 'deck', deck)
      const localVarPath = `/decks`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        deck,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grammarsetsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/grammarsets`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grammarsetsIdDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('grammarsetsIdDelete', 'id', id)
      const localVarPath = `/grammarsets/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grammarsetsIdGet: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('grammarsetsIdGet', 'id', id)
      const localVarPath = `/grammarsets/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {GrammarSet} grammarSet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grammarsetsIdPatch: async (
      id: string,
      grammarSet: GrammarSet,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('grammarsetsIdPatch', 'id', id)
      // verify required parameter 'grammarSet' is not null or undefined
      assertParamExists('grammarsetsIdPatch', 'grammarSet', grammarSet)
      const localVarPath = `/grammarsets/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        grammarSet,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {GrammarSet} grammarSet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grammarsetsPost: async (
      grammarSet: GrammarSet,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'grammarSet' is not null or undefined
      assertParamExists('grammarsetsPost', 'grammarSet', grammarSet)
      const localVarPath = `/grammarsets`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        grammarSet,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} setId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grammarsetsSetIdGrammarsGet: async (
      setId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'setId' is not null or undefined
      assertParamExists('grammarsetsSetIdGrammarsGet', 'setId', setId)
      const localVarPath = `/grammarsets/{setId}/grammars`.replace(
        `{${'setId'}}`,
        encodeURIComponent(String(setId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} setId
     * @param {string} grammarId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grammarsetsSetIdGrammarsGrammarIdDelete: async (
      setId: string,
      grammarId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'setId' is not null or undefined
      assertParamExists('grammarsetsSetIdGrammarsGrammarIdDelete', 'setId', setId)
      // verify required parameter 'grammarId' is not null or undefined
      assertParamExists('grammarsetsSetIdGrammarsGrammarIdDelete', 'grammarId', grammarId)
      const localVarPath = `/grammarsets/{setId}/grammars/{grammarId}`
        .replace(`{${'setId'}}`, encodeURIComponent(String(setId)))
        .replace(`{${'grammarId'}}`, encodeURIComponent(String(grammarId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} setId
     * @param {string} grammarId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grammarsetsSetIdGrammarsGrammarIdGet: async (
      setId: string,
      grammarId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'setId' is not null or undefined
      assertParamExists('grammarsetsSetIdGrammarsGrammarIdGet', 'setId', setId)
      // verify required parameter 'grammarId' is not null or undefined
      assertParamExists('grammarsetsSetIdGrammarsGrammarIdGet', 'grammarId', grammarId)
      const localVarPath = `/grammarsets/{setId}/grammars/{grammarId}`
        .replace(`{${'setId'}}`, encodeURIComponent(String(setId)))
        .replace(`{${'grammarId'}}`, encodeURIComponent(String(grammarId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} setId
     * @param {string} grammarId
     * @param {Grammar} grammar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grammarsetsSetIdGrammarsGrammarIdPatch: async (
      setId: string,
      grammarId: string,
      grammar: Grammar,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'setId' is not null or undefined
      assertParamExists('grammarsetsSetIdGrammarsGrammarIdPatch', 'setId', setId)
      // verify required parameter 'grammarId' is not null or undefined
      assertParamExists('grammarsetsSetIdGrammarsGrammarIdPatch', 'grammarId', grammarId)
      // verify required parameter 'grammar' is not null or undefined
      assertParamExists('grammarsetsSetIdGrammarsGrammarIdPatch', 'grammar', grammar)
      const localVarPath = `/grammarsets/{setId}/grammars/{grammarId}`
        .replace(`{${'setId'}}`, encodeURIComponent(String(setId)))
        .replace(`{${'grammarId'}}`, encodeURIComponent(String(grammarId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        grammar,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} setId
     * @param {Grammar} grammar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grammarsetsSetIdGrammarsPost: async (
      setId: string,
      grammar: Grammar,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'setId' is not null or undefined
      assertParamExists('grammarsetsSetIdGrammarsPost', 'setId', setId)
      // verify required parameter 'grammar' is not null or undefined
      assertParamExists('grammarsetsSetIdGrammarsPost', 'grammar', grammar)
      const localVarPath = `/grammarsets/{setId}/grammars`.replace(
        `{${'setId'}}`,
        encodeURIComponent(String(setId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        grammar,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * LangLearnBackendApi - functional programming interface
 */
export const LangLearnBackendApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LangLearnBackendApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authGet(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResultDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authGet(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LangLearnBackendApi.authGet']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {LoginRequestDto} loginRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authLoginPost(
      loginRequestDto: LoginRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResultDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginPost(
        loginRequestDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LangLearnBackendApi.authLoginPost']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {RefreshTokenRequestDto} refreshTokenRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authRefreshPost(
      refreshTokenRequestDto: RefreshTokenRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResultDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authRefreshPost(
        refreshTokenRequestDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LangLearnBackendApi.authRefreshPost']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {RegisterRequestDto} registerRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authRegisterPost(
      registerRequestDto: RegisterRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResultDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authRegisterPost(
        registerRequestDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LangLearnBackendApi.authRegisterPost']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} deckId
     * @param {string} flashcardId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async decksDeckIdFlashcardsFlashcardIdDelete(
      deckId: string,
      flashcardId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.decksDeckIdFlashcardsFlashcardIdDelete(
          deckId,
          flashcardId,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LangLearnBackendApi.decksDeckIdFlashcardsFlashcardIdDelete']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} deckId
     * @param {string} flashcardId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async decksDeckIdFlashcardsFlashcardIdGet(
      deckId: string,
      flashcardId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlashcardDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.decksDeckIdFlashcardsFlashcardIdGet(
        deckId,
        flashcardId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LangLearnBackendApi.decksDeckIdFlashcardsFlashcardIdGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} deckId
     * @param {string} flashcardId
     * @param {Flashcard} flashcard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async decksDeckIdFlashcardsFlashcardIdPatch(
      deckId: string,
      flashcardId: string,
      flashcard: Flashcard,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlashcardDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.decksDeckIdFlashcardsFlashcardIdPatch(
          deckId,
          flashcardId,
          flashcard,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LangLearnBackendApi.decksDeckIdFlashcardsFlashcardIdPatch']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} deckId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async decksDeckIdFlashcardsGet(
      deckId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FlashcardDto>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.decksDeckIdFlashcardsGet(
        deckId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LangLearnBackendApi.decksDeckIdFlashcardsGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} deckId
     * @param {Flashcard} flashcard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async decksDeckIdFlashcardsPost(
      deckId: string,
      flashcard: Flashcard,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlashcardDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.decksDeckIdFlashcardsPost(
        deckId,
        flashcard,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LangLearnBackendApi.decksDeckIdFlashcardsPost']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async decksGet(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeckDto>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.decksGet(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LangLearnBackendApi.decksGet']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async decksIdDelete(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.decksIdDelete(id, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LangLearnBackendApi.decksIdDelete']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async decksIdGet(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeckDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.decksIdGet(id, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LangLearnBackendApi.decksIdGet']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} id
     * @param {Deck} deck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async decksIdPatch(
      id: string,
      deck: Deck,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeckDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.decksIdPatch(id, deck, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LangLearnBackendApi.decksIdPatch']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {Deck} deck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async decksPost(
      deck: Deck,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeckDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.decksPost(deck, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LangLearnBackendApi.decksPost']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async grammarsetsGet(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GrammarSetDto>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.grammarsetsGet(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LangLearnBackendApi.grammarsetsGet']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async grammarsetsIdDelete(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.grammarsetsIdDelete(id, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LangLearnBackendApi.grammarsetsIdDelete']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async grammarsetsIdGet(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GrammarSetDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.grammarsetsIdGet(id, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LangLearnBackendApi.grammarsetsIdGet']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} id
     * @param {GrammarSet} grammarSet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async grammarsetsIdPatch(
      id: string,
      grammarSet: GrammarSet,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GrammarSetDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.grammarsetsIdPatch(
        id,
        grammarSet,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LangLearnBackendApi.grammarsetsIdPatch']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {GrammarSet} grammarSet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async grammarsetsPost(
      grammarSet: GrammarSet,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GrammarSetDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.grammarsetsPost(grammarSet, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LangLearnBackendApi.grammarsetsPost']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} setId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async grammarsetsSetIdGrammarsGet(
      setId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GrammarDto>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.grammarsetsSetIdGrammarsGet(
        setId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LangLearnBackendApi.grammarsetsSetIdGrammarsGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} setId
     * @param {string} grammarId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async grammarsetsSetIdGrammarsGrammarIdDelete(
      setId: string,
      grammarId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.grammarsetsSetIdGrammarsGrammarIdDelete(
          setId,
          grammarId,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LangLearnBackendApi.grammarsetsSetIdGrammarsGrammarIdDelete']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} setId
     * @param {string} grammarId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async grammarsetsSetIdGrammarsGrammarIdGet(
      setId: string,
      grammarId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GrammarDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.grammarsetsSetIdGrammarsGrammarIdGet(
          setId,
          grammarId,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LangLearnBackendApi.grammarsetsSetIdGrammarsGrammarIdGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} setId
     * @param {string} grammarId
     * @param {Grammar} grammar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async grammarsetsSetIdGrammarsGrammarIdPatch(
      setId: string,
      grammarId: string,
      grammar: Grammar,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GrammarDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.grammarsetsSetIdGrammarsGrammarIdPatch(
          setId,
          grammarId,
          grammar,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LangLearnBackendApi.grammarsetsSetIdGrammarsGrammarIdPatch']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} setId
     * @param {Grammar} grammar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async grammarsetsSetIdGrammarsPost(
      setId: string,
      grammar: Grammar,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GrammarDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.grammarsetsSetIdGrammarsPost(
        setId,
        grammar,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['LangLearnBackendApi.grammarsetsSetIdGrammarsPost']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * LangLearnBackendApi - factory interface
 */
export const LangLearnBackendApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = LangLearnBackendApiFp(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authGet(options?: RawAxiosRequestConfig): AxiosPromise<AuthResultDto> {
      return localVarFp.authGet(options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {LangLearnBackendApiAuthLoginPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authLoginPost(
      requestParameters: LangLearnBackendApiAuthLoginPostRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AuthResultDto> {
      return localVarFp
        .authLoginPost(requestParameters.loginRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {LangLearnBackendApiAuthRefreshPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authRefreshPost(
      requestParameters: LangLearnBackendApiAuthRefreshPostRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AuthResultDto> {
      return localVarFp
        .authRefreshPost(requestParameters.refreshTokenRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {LangLearnBackendApiAuthRegisterPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authRegisterPost(
      requestParameters: LangLearnBackendApiAuthRegisterPostRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AuthResultDto> {
      return localVarFp
        .authRegisterPost(requestParameters.registerRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {LangLearnBackendApiDecksDeckIdFlashcardsFlashcardIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decksDeckIdFlashcardsFlashcardIdDelete(
      requestParameters: LangLearnBackendApiDecksDeckIdFlashcardsFlashcardIdDeleteRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .decksDeckIdFlashcardsFlashcardIdDelete(
          requestParameters.deckId,
          requestParameters.flashcardId,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {LangLearnBackendApiDecksDeckIdFlashcardsFlashcardIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decksDeckIdFlashcardsFlashcardIdGet(
      requestParameters: LangLearnBackendApiDecksDeckIdFlashcardsFlashcardIdGetRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<FlashcardDto> {
      return localVarFp
        .decksDeckIdFlashcardsFlashcardIdGet(
          requestParameters.deckId,
          requestParameters.flashcardId,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {LangLearnBackendApiDecksDeckIdFlashcardsFlashcardIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decksDeckIdFlashcardsFlashcardIdPatch(
      requestParameters: LangLearnBackendApiDecksDeckIdFlashcardsFlashcardIdPatchRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<FlashcardDto> {
      return localVarFp
        .decksDeckIdFlashcardsFlashcardIdPatch(
          requestParameters.deckId,
          requestParameters.flashcardId,
          requestParameters.flashcard,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {LangLearnBackendApiDecksDeckIdFlashcardsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decksDeckIdFlashcardsGet(
      requestParameters: LangLearnBackendApiDecksDeckIdFlashcardsGetRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<FlashcardDto>> {
      return localVarFp
        .decksDeckIdFlashcardsGet(requestParameters.deckId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {LangLearnBackendApiDecksDeckIdFlashcardsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decksDeckIdFlashcardsPost(
      requestParameters: LangLearnBackendApiDecksDeckIdFlashcardsPostRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<FlashcardDto> {
      return localVarFp
        .decksDeckIdFlashcardsPost(requestParameters.deckId, requestParameters.flashcard, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decksGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<DeckDto>> {
      return localVarFp.decksGet(options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {LangLearnBackendApiDecksIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decksIdDelete(
      requestParameters: LangLearnBackendApiDecksIdDeleteRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .decksIdDelete(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {LangLearnBackendApiDecksIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decksIdGet(
      requestParameters: LangLearnBackendApiDecksIdGetRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DeckDto> {
      return localVarFp
        .decksIdGet(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {LangLearnBackendApiDecksIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decksIdPatch(
      requestParameters: LangLearnBackendApiDecksIdPatchRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DeckDto> {
      return localVarFp
        .decksIdPatch(requestParameters.id, requestParameters.deck, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {LangLearnBackendApiDecksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decksPost(
      requestParameters: LangLearnBackendApiDecksPostRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DeckDto> {
      return localVarFp
        .decksPost(requestParameters.deck, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grammarsetsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<GrammarSetDto>> {
      return localVarFp.grammarsetsGet(options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {LangLearnBackendApiGrammarsetsIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grammarsetsIdDelete(
      requestParameters: LangLearnBackendApiGrammarsetsIdDeleteRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .grammarsetsIdDelete(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {LangLearnBackendApiGrammarsetsIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grammarsetsIdGet(
      requestParameters: LangLearnBackendApiGrammarsetsIdGetRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GrammarSetDto> {
      return localVarFp
        .grammarsetsIdGet(requestParameters.id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {LangLearnBackendApiGrammarsetsIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grammarsetsIdPatch(
      requestParameters: LangLearnBackendApiGrammarsetsIdPatchRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GrammarSetDto> {
      return localVarFp
        .grammarsetsIdPatch(requestParameters.id, requestParameters.grammarSet, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {LangLearnBackendApiGrammarsetsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grammarsetsPost(
      requestParameters: LangLearnBackendApiGrammarsetsPostRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GrammarSetDto> {
      return localVarFp
        .grammarsetsPost(requestParameters.grammarSet, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {LangLearnBackendApiGrammarsetsSetIdGrammarsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grammarsetsSetIdGrammarsGet(
      requestParameters: LangLearnBackendApiGrammarsetsSetIdGrammarsGetRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<GrammarDto>> {
      return localVarFp
        .grammarsetsSetIdGrammarsGet(requestParameters.setId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {LangLearnBackendApiGrammarsetsSetIdGrammarsGrammarIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grammarsetsSetIdGrammarsGrammarIdDelete(
      requestParameters: LangLearnBackendApiGrammarsetsSetIdGrammarsGrammarIdDeleteRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .grammarsetsSetIdGrammarsGrammarIdDelete(
          requestParameters.setId,
          requestParameters.grammarId,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {LangLearnBackendApiGrammarsetsSetIdGrammarsGrammarIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grammarsetsSetIdGrammarsGrammarIdGet(
      requestParameters: LangLearnBackendApiGrammarsetsSetIdGrammarsGrammarIdGetRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GrammarDto> {
      return localVarFp
        .grammarsetsSetIdGrammarsGrammarIdGet(
          requestParameters.setId,
          requestParameters.grammarId,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {LangLearnBackendApiGrammarsetsSetIdGrammarsGrammarIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grammarsetsSetIdGrammarsGrammarIdPatch(
      requestParameters: LangLearnBackendApiGrammarsetsSetIdGrammarsGrammarIdPatchRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GrammarDto> {
      return localVarFp
        .grammarsetsSetIdGrammarsGrammarIdPatch(
          requestParameters.setId,
          requestParameters.grammarId,
          requestParameters.grammar,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {LangLearnBackendApiGrammarsetsSetIdGrammarsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grammarsetsSetIdGrammarsPost(
      requestParameters: LangLearnBackendApiGrammarsetsSetIdGrammarsPostRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GrammarDto> {
      return localVarFp
        .grammarsetsSetIdGrammarsPost(requestParameters.setId, requestParameters.grammar, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for authLoginPost operation in LangLearnBackendApi.
 */
export interface LangLearnBackendApiAuthLoginPostRequest {
  readonly loginRequestDto: LoginRequestDto
}

/**
 * Request parameters for authRefreshPost operation in LangLearnBackendApi.
 */
export interface LangLearnBackendApiAuthRefreshPostRequest {
  readonly refreshTokenRequestDto: RefreshTokenRequestDto
}

/**
 * Request parameters for authRegisterPost operation in LangLearnBackendApi.
 */
export interface LangLearnBackendApiAuthRegisterPostRequest {
  readonly registerRequestDto: RegisterRequestDto
}

/**
 * Request parameters for decksDeckIdFlashcardsFlashcardIdDelete operation in LangLearnBackendApi.
 */
export interface LangLearnBackendApiDecksDeckIdFlashcardsFlashcardIdDeleteRequest {
  readonly deckId: string

  readonly flashcardId: string
}

/**
 * Request parameters for decksDeckIdFlashcardsFlashcardIdGet operation in LangLearnBackendApi.
 */
export interface LangLearnBackendApiDecksDeckIdFlashcardsFlashcardIdGetRequest {
  readonly deckId: string

  readonly flashcardId: string
}

/**
 * Request parameters for decksDeckIdFlashcardsFlashcardIdPatch operation in LangLearnBackendApi.
 */
export interface LangLearnBackendApiDecksDeckIdFlashcardsFlashcardIdPatchRequest {
  readonly deckId: string

  readonly flashcardId: string

  readonly flashcard: Flashcard
}

/**
 * Request parameters for decksDeckIdFlashcardsGet operation in LangLearnBackendApi.
 */
export interface LangLearnBackendApiDecksDeckIdFlashcardsGetRequest {
  readonly deckId: string
}

/**
 * Request parameters for decksDeckIdFlashcardsPost operation in LangLearnBackendApi.
 */
export interface LangLearnBackendApiDecksDeckIdFlashcardsPostRequest {
  readonly deckId: string

  readonly flashcard: Flashcard
}

/**
 * Request parameters for decksIdDelete operation in LangLearnBackendApi.
 */
export interface LangLearnBackendApiDecksIdDeleteRequest {
  readonly id: string
}

/**
 * Request parameters for decksIdGet operation in LangLearnBackendApi.
 */
export interface LangLearnBackendApiDecksIdGetRequest {
  readonly id: string
}

/**
 * Request parameters for decksIdPatch operation in LangLearnBackendApi.
 */
export interface LangLearnBackendApiDecksIdPatchRequest {
  readonly id: string

  readonly deck: Deck
}

/**
 * Request parameters for decksPost operation in LangLearnBackendApi.
 */
export interface LangLearnBackendApiDecksPostRequest {
  readonly deck: Deck
}

/**
 * Request parameters for grammarsetsIdDelete operation in LangLearnBackendApi.
 */
export interface LangLearnBackendApiGrammarsetsIdDeleteRequest {
  readonly id: string
}

/**
 * Request parameters for grammarsetsIdGet operation in LangLearnBackendApi.
 */
export interface LangLearnBackendApiGrammarsetsIdGetRequest {
  readonly id: string
}

/**
 * Request parameters for grammarsetsIdPatch operation in LangLearnBackendApi.
 */
export interface LangLearnBackendApiGrammarsetsIdPatchRequest {
  readonly id: string

  readonly grammarSet: GrammarSet
}

/**
 * Request parameters for grammarsetsPost operation in LangLearnBackendApi.
 */
export interface LangLearnBackendApiGrammarsetsPostRequest {
  readonly grammarSet: GrammarSet
}

/**
 * Request parameters for grammarsetsSetIdGrammarsGet operation in LangLearnBackendApi.
 */
export interface LangLearnBackendApiGrammarsetsSetIdGrammarsGetRequest {
  readonly setId: string
}

/**
 * Request parameters for grammarsetsSetIdGrammarsGrammarIdDelete operation in LangLearnBackendApi.
 */
export interface LangLearnBackendApiGrammarsetsSetIdGrammarsGrammarIdDeleteRequest {
  readonly setId: string

  readonly grammarId: string
}

/**
 * Request parameters for grammarsetsSetIdGrammarsGrammarIdGet operation in LangLearnBackendApi.
 */
export interface LangLearnBackendApiGrammarsetsSetIdGrammarsGrammarIdGetRequest {
  readonly setId: string

  readonly grammarId: string
}

/**
 * Request parameters for grammarsetsSetIdGrammarsGrammarIdPatch operation in LangLearnBackendApi.
 */
export interface LangLearnBackendApiGrammarsetsSetIdGrammarsGrammarIdPatchRequest {
  readonly setId: string

  readonly grammarId: string

  readonly grammar: Grammar
}

/**
 * Request parameters for grammarsetsSetIdGrammarsPost operation in LangLearnBackendApi.
 */
export interface LangLearnBackendApiGrammarsetsSetIdGrammarsPostRequest {
  readonly setId: string

  readonly grammar: Grammar
}

/**
 * LangLearnBackendApi - object-oriented interface
 */
export class LangLearnBackendApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public authGet(options?: RawAxiosRequestConfig) {
    return LangLearnBackendApiFp(this.configuration)
      .authGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {LangLearnBackendApiAuthLoginPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public authLoginPost(
    requestParameters: LangLearnBackendApiAuthLoginPostRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return LangLearnBackendApiFp(this.configuration)
      .authLoginPost(requestParameters.loginRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {LangLearnBackendApiAuthRefreshPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public authRefreshPost(
    requestParameters: LangLearnBackendApiAuthRefreshPostRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return LangLearnBackendApiFp(this.configuration)
      .authRefreshPost(requestParameters.refreshTokenRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {LangLearnBackendApiAuthRegisterPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public authRegisterPost(
    requestParameters: LangLearnBackendApiAuthRegisterPostRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return LangLearnBackendApiFp(this.configuration)
      .authRegisterPost(requestParameters.registerRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {LangLearnBackendApiDecksDeckIdFlashcardsFlashcardIdDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public decksDeckIdFlashcardsFlashcardIdDelete(
    requestParameters: LangLearnBackendApiDecksDeckIdFlashcardsFlashcardIdDeleteRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return LangLearnBackendApiFp(this.configuration)
      .decksDeckIdFlashcardsFlashcardIdDelete(
        requestParameters.deckId,
        requestParameters.flashcardId,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {LangLearnBackendApiDecksDeckIdFlashcardsFlashcardIdGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public decksDeckIdFlashcardsFlashcardIdGet(
    requestParameters: LangLearnBackendApiDecksDeckIdFlashcardsFlashcardIdGetRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return LangLearnBackendApiFp(this.configuration)
      .decksDeckIdFlashcardsFlashcardIdGet(
        requestParameters.deckId,
        requestParameters.flashcardId,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {LangLearnBackendApiDecksDeckIdFlashcardsFlashcardIdPatchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public decksDeckIdFlashcardsFlashcardIdPatch(
    requestParameters: LangLearnBackendApiDecksDeckIdFlashcardsFlashcardIdPatchRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return LangLearnBackendApiFp(this.configuration)
      .decksDeckIdFlashcardsFlashcardIdPatch(
        requestParameters.deckId,
        requestParameters.flashcardId,
        requestParameters.flashcard,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {LangLearnBackendApiDecksDeckIdFlashcardsGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public decksDeckIdFlashcardsGet(
    requestParameters: LangLearnBackendApiDecksDeckIdFlashcardsGetRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return LangLearnBackendApiFp(this.configuration)
      .decksDeckIdFlashcardsGet(requestParameters.deckId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {LangLearnBackendApiDecksDeckIdFlashcardsPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public decksDeckIdFlashcardsPost(
    requestParameters: LangLearnBackendApiDecksDeckIdFlashcardsPostRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return LangLearnBackendApiFp(this.configuration)
      .decksDeckIdFlashcardsPost(requestParameters.deckId, requestParameters.flashcard, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public decksGet(options?: RawAxiosRequestConfig) {
    return LangLearnBackendApiFp(this.configuration)
      .decksGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {LangLearnBackendApiDecksIdDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public decksIdDelete(
    requestParameters: LangLearnBackendApiDecksIdDeleteRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return LangLearnBackendApiFp(this.configuration)
      .decksIdDelete(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {LangLearnBackendApiDecksIdGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public decksIdGet(
    requestParameters: LangLearnBackendApiDecksIdGetRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return LangLearnBackendApiFp(this.configuration)
      .decksIdGet(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {LangLearnBackendApiDecksIdPatchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public decksIdPatch(
    requestParameters: LangLearnBackendApiDecksIdPatchRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return LangLearnBackendApiFp(this.configuration)
      .decksIdPatch(requestParameters.id, requestParameters.deck, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {LangLearnBackendApiDecksPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public decksPost(
    requestParameters: LangLearnBackendApiDecksPostRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return LangLearnBackendApiFp(this.configuration)
      .decksPost(requestParameters.deck, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public grammarsetsGet(options?: RawAxiosRequestConfig) {
    return LangLearnBackendApiFp(this.configuration)
      .grammarsetsGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {LangLearnBackendApiGrammarsetsIdDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public grammarsetsIdDelete(
    requestParameters: LangLearnBackendApiGrammarsetsIdDeleteRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return LangLearnBackendApiFp(this.configuration)
      .grammarsetsIdDelete(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {LangLearnBackendApiGrammarsetsIdGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public grammarsetsIdGet(
    requestParameters: LangLearnBackendApiGrammarsetsIdGetRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return LangLearnBackendApiFp(this.configuration)
      .grammarsetsIdGet(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {LangLearnBackendApiGrammarsetsIdPatchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public grammarsetsIdPatch(
    requestParameters: LangLearnBackendApiGrammarsetsIdPatchRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return LangLearnBackendApiFp(this.configuration)
      .grammarsetsIdPatch(requestParameters.id, requestParameters.grammarSet, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {LangLearnBackendApiGrammarsetsPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public grammarsetsPost(
    requestParameters: LangLearnBackendApiGrammarsetsPostRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return LangLearnBackendApiFp(this.configuration)
      .grammarsetsPost(requestParameters.grammarSet, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {LangLearnBackendApiGrammarsetsSetIdGrammarsGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public grammarsetsSetIdGrammarsGet(
    requestParameters: LangLearnBackendApiGrammarsetsSetIdGrammarsGetRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return LangLearnBackendApiFp(this.configuration)
      .grammarsetsSetIdGrammarsGet(requestParameters.setId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {LangLearnBackendApiGrammarsetsSetIdGrammarsGrammarIdDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public grammarsetsSetIdGrammarsGrammarIdDelete(
    requestParameters: LangLearnBackendApiGrammarsetsSetIdGrammarsGrammarIdDeleteRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return LangLearnBackendApiFp(this.configuration)
      .grammarsetsSetIdGrammarsGrammarIdDelete(
        requestParameters.setId,
        requestParameters.grammarId,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {LangLearnBackendApiGrammarsetsSetIdGrammarsGrammarIdGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public grammarsetsSetIdGrammarsGrammarIdGet(
    requestParameters: LangLearnBackendApiGrammarsetsSetIdGrammarsGrammarIdGetRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return LangLearnBackendApiFp(this.configuration)
      .grammarsetsSetIdGrammarsGrammarIdGet(
        requestParameters.setId,
        requestParameters.grammarId,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {LangLearnBackendApiGrammarsetsSetIdGrammarsGrammarIdPatchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public grammarsetsSetIdGrammarsGrammarIdPatch(
    requestParameters: LangLearnBackendApiGrammarsetsSetIdGrammarsGrammarIdPatchRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return LangLearnBackendApiFp(this.configuration)
      .grammarsetsSetIdGrammarsGrammarIdPatch(
        requestParameters.setId,
        requestParameters.grammarId,
        requestParameters.grammar,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {LangLearnBackendApiGrammarsetsSetIdGrammarsPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public grammarsetsSetIdGrammarsPost(
    requestParameters: LangLearnBackendApiGrammarsetsSetIdGrammarsPostRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return LangLearnBackendApiFp(this.configuration)
      .grammarsetsSetIdGrammarsPost(requestParameters.setId, requestParameters.grammar, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
